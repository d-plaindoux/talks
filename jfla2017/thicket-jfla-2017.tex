\documentclass[twoside,a4paper]{article}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinelanguage{Thicket}
{  
  morekeywords={
    adapter, module,from, import, export,
    type, enum, trait, model, class, 
    def, let, in, if, for, yield, 
    new, with
  },
  alsoother={-><?()},
  sensitive=true, % keywords are not case-sensitive
  morecomment=[l]{//}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}

\lstset{
  numbers=left,
  stepnumber=1,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=false,
  tabsize=4
}

\lstset{language=Html}
\lstset{
 morekeywords={ adapter, module,from, import, export,
    typedef, type, trait, model, class, 
    def, let, in, if, for, yield, 
    new, with}
}

\lstset{
    literate={~} {$\sim$}{1}
}

\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes}
\usepackage[french]{babel}
\title{ Du Web fonctionnel avec le langage Thicket }
\author{Didier Plaindoux$^1$}
% les titres de haut de pages
\titlehead{ Du Web fonctionnel avec le langage Thicket }%  a droite (page impaire)
\authorhead{Didier Plaindoux}% a gauche (page paire)
\affiliation{\begin{tabular}{rr} 
    \\ 1:  Fungus, Le village 31430 Gratens, France
    \\     {\tt d.plaindoux@fungus.fr}
\end{tabular}}

\begin{document}

\setcounter{page}{1}
\maketitle

\begin{abstract}
Nous pouvons  constater actuellement,  dans le monde  du développement
logiciel,   une  forte   adoption   du   paradigme  fonctionnel.   Les
applications  dites   Web  comptent  parmis  les   vecteurs  les  plus
importants pour la promotion de  cette approche. Ceci est notamment le
fait de langages fonctionnels fortement typés tels que Eml, Purescript
ou ScalaJS pour  ne citer qu’eux. Cependant ces  derniers reposent sur
un schéma  de compilation  procédant par  une “transpilation”  vers le
langage cible Javascript.

Cet article  court propose  d'aborder le  développement d'applications
clientes Web avec le langage  Thicket. Ce langage s’inscrit dans cette
mouvance des langages fonctionnels fortement  typés qui ciblent le Web
tout  en  y  intégrant  une  machine  virtuelle  spécifique  pour  son
exécution. Il dispose  de plus de constructions  syntaxiques dédiées à
la  dénotation  de  termes  HTML   afin  de  proposer  une  expression
déclarative de  la composition  de documents. Nous  verrons finalement
comment  ce langage  peut être  intégré  dans un  client. Cela  couvre
notamment le schéma  de compilation traditionnel mais  aussi un schéma
de compilation dit à la volée.
\end{abstract}

\section{Introduction}

Malgré l'existence  de langages  tels que  OCaml \cite{ocaml}  ou bien
Haskell \cite{haskell}, les principaux vecteurs de cet engouement sont
des  langages   hybrides  comme   Scala  \cite{scala}  ou   bien  Java
\cite{java8} avec son adoption des lambdas.

Cependant cet  engouement se trouve  aussi bien  porté par le  Web qui
accentue cette  mouvance. Ceci  est le  fait de  langages fonctionnels
fortement typés tels que  Eml \cite{elm}, Purescript \cite{purescript}
ou ScalaJS \cite{scalajs} pour ne citer qu’eux. Cependant ces derniers
reposent   sur   un   schéma   de  compilation   procédant   par   une
“transpilation” vers  le langage  cible Javascript. Malgré  les étapes
d’optimisation  mises  en  oeuvre  comme  par  exemple  le  traitement
spécifique  de la  recursion  terminale, une  telle transformation  ne
permet pas d’avoir une maitrise totale  du langage et de son exécution
comme  cela peut  être  le  cas avec  le  support  d’une machine  SECD
spécifique.

Cette dernière approche soulève cependant plusieurs problèmatiques. La
première  concerne l'expressivité  du langage  et notamment  lorsqu'il
s'agit de manipuler  le DOM \cite{dom}. En effet, a  l'instar de React
\cite{reacjs} ou Angular  \cite{angular2} qui sont centrés  sur le DOM
et sa manipulation,  la plupart des solutions  proposées procédent par
une  approche  fonctionnelle  des  balises HTML  rendant  de  ce  fait
difficile  la  conception.  Le  second  problème  concerne  le  modèle
d'éxécution qui  passe par la  plupart du temps par  une transpilation
vers Javascript.

Lors de l'élaboration  du langage Thicket ces  deux problèmatiques ont
été   particulièrement  ciblées   afin  d'étudier   l'expressivité  et
l'intégration dans le monde des applications dites Web.

\section{Survol rapide du langage Thicket}

Thicket  est  un  langage  fonctionnel  fortement  typé  à  évaluation
paresseuse  intégrant  le  paradigme  objet par  l'apport  des  traits
\cite{trait} et  d'un principe de  séparation entre les classes  et le
modèle quelle dénote.

\subsection{Modèle pour la représentation de données}

Toute  information plus  ou moins  complexe peut  être dénotée  par un
ensemble spécifique  de données et  un mode de représentation  tel que
l'enregistrement  \cite{RecordCalculus}  est  un  bon  candidats.   On
distingue alors  deux types de données  a savoir les simple  ayant une
formulation unique et  les unions quand un type de  données peut avoir
plusieurs formes de représentations.

\subsubsection{Modèle de donnée}

Une  données  est  représentée   par  un  ensemble  d'attributs  nommé
\cite{Cardelli} \cite{Haskell}.

\lstset{language=Thicket}
\begin{lstlisting}
  model Humain {  // : string -> number -> Humain
    nom : string   
    age : number
  }
\end{lstlisting}

Une  fonction  de génération  pour  le  type  {\tt Humain}  est  alors
synthétisée avec  une signature  calquant le  type des  attributs dans
l'ordre de  spécification.  Construire  une donnée correspond  alors à
appliquer cette fonction.

\lstset{language=Thicket}
\begin{lstlisting}
  Humain "Anakin Skywalker" 1 // : Humain
\end{lstlisting}

Le langage propose aussi la définition  de donnée a multiple forme par
énumération  au  même  tire   que  les  types  injectifs  \cite{Ocaml}
\cite{Haskell} ou les {\it case class} \cite{Scala}.

\subsection{Manipulation des données}

Le  langage  a été  bati  autour  des  concepts de  fonctions,  traits
\cite{traits} et classes.  Cependant la notion de  classe reposant sur
des états  mutable n'est  pas celle adoptée.   En effet  souhaitant un
langage  ou la  mutabilité est  tout simplemenet  proscrite la  notion
d'état d'un objet peut être revisité.  Pour ce faire nous avons repris
la  notion  de  classe  comme  générateur  prenant  en  paramètre  une
expression et propose en retour une base de connaissance dans laquelle
{\tt self}  dénote cette même base  au même titre que  {\tt this} dans
Scala.

\lstset{language=Thicket}
\begin{lstlisting}
  class jedi this:Humain { // : Humain -> jedi
    nom : string
    grade : string
  } {
    def grade = this.age ?> 19 fold "Maitre" "Padawan"
  }
\end{lstlisting}

% CF these

Cette  approche permet  de séparer le  model du  controlleur ou  plus
généralement  ce ``qu'il  est'' de  ``ce  qu'il fait''.  Ceci va  nous
permettre d'avoir plusieurs niveaux d'interpétation d'une même donnée.

\lstset{language=Thicket}
\begin{lstlisting}
  jedi (Humain "Anakin Skywalker" 1) // : jedi
\end{lstlisting}

\subsection{Immutabilité et système évolutif}

Un  des principes  de base  concerne l'immutabilité.   En effet  toute
donnée est considérée  comme immutable et ne peut  être alors modifiée
directement. L'unique approche consiste à proposer un système basé sur
l'évolution de donnée. Cette approche  existe de facto dans Haskell ou
OCaml (sans  le mutable)  mais aussi dans  des langages  récents comme
Swift \cite{Swift}  avec la notion  de structure et de  mutabilité par
copie partielle.

Il est possible de produire un nouvelle version de données par le bien
d'une structure  de contrôle  spécifique comme le  montre le  code qui
suit.

\lstset{language=Thicket}
\begin{lstlisting}
  new Humain "Anakin Skywalker" with nom="Darth Vader"
\end{lstlisting}

Cette  même  structure  de  contrôle permet  aussi  d'opérér  sur  une
instance de  classe et  permettre ainsi  de faire  évoluer la  base de
connaissance d'une instance dans le temps.

\lstset{language=Thicket}
\begin{lstlisting}
  class jedi humain:Humain {
    humain : string
    grade : string
    anniversaire : jedi
  } {
    def nom = humain.nom
    def grade = humain.age ?> 19 fold "Maitre" "Padawan"
    def anniversaire = jedi new humain with age=(humain.age+1)
  }
\end{lstlisting}

\subsection{Client Web et DOM}

Dans la  majorité des  solutions la  mise en forme  et la  création de
document  sont   prisent  en  charge   par  des  librairies   pour  la
construction de termes  pour le DOM. Il existe  cependant une approche
descriptive  par  opposition  à   une  approche  calculée  qui  permet
d'exprimer des  fragments et ce  de manière plus intuitive  comme cela
est  notamment  le  cas   dans  AngularJS  \cite{angularjs}  et  React
\cite{react}.

\subsubsection{Expression de la structure d'un fragment}

Notre approche est sensiblement différente  car elle propose un modèle
d'expression qui est  transformé en expression fonctionnel  lors de la
phase de  compilation. Une telle  approche permet de combiner  une vue
plus  intuitive  de la  construction  de  document sans  corrompre  le
système complet.

\lstset{language=Thicket}
\begin{lstlisting}
  def vue : jedi -> dom = h -> <p> j.grade " " j.nom </p> 
\end{lstlisting}

\noindent Cette expression peut-être transcrite par le biais des librairies actuelles
de la façon suivante:

\begin{lstlisting}
  def vue : jedi -> dom = h -> {
      document "p" create addChild j.grade addChild " " addChild j.nom
  }
\end{lstlisting}

\subsubsection{Définition d'un système réactif}

Par contre contrairement à ce que propose HTML le comportement associé
à un noeud  du dom est séparé de la  représentation.  Il devient alors
ainsi facile de  concevoir des systèmes réactifs par la  mise en place
de  points  d'appels.  Il  devient ainsi  plus  aisé  d'appéhender  la
structure du document mais aussi les comportements associées.

\begin{lstlisting}
  def vue : jedi -> dom = j -> {
    <p id="jedi"> j.grade " "  j.nom </p> 
    onMouseEvent MouseClick $ n -> console log "Click ..."
  }
\end{lstlisting}


\section{Une intégration Web sur mesure}

L'intégrtion dans  le monde du  Web permet d'executer du  code Thicket
comme tout langage de script dans les pages HTML. Ceci peut être alors
obtenu de  deux façons différentes.  La première classique  consiste à
encapsluer du code directement dans un balise script au même titre que
Javascript. Le seconde adoptée par la pluparts des languages consiste 
à compiler voire transpiler le code.

\subsection{Page HTML, Application et Thicket}

\lstset{language=Html}
\begin{lstlisting}
  <html lang="en">
  <head>
    <script src="/thicket/build/thicket-web-lang.min.js"></script>    
    <script type="application/javascript">
      function onLoad() { require('thicket')('/thicket/site').boot(); }
    </script>

    <script type="application/thicket+package" data-src="Client"></script>
    <script type="application/thicket+package" data-src="Jedi"></script>
    <script type="application/thicket">
      def vue : jedi -> dom = j -> {
        <p id="jedi"> j.grade " "  j.nom </p> 
        onMouseEvent MouseClick $ _ -> documentRenderer <~ (vue $ j anniversaire)
      }

      documentRenderer <~ $ jedi $ Humain "Obi-Wan Kenobi" 1
    </script>
  </head>        
    <body onload="onLoad()">
     <p id="jedi"/>
  </body>
  </html>
\end{lstlisting}

\subsection{Le modèle de compilation}

\subsection{Application Web et immutabilité}

\subsection{Modèle de distribution}

\section{Conclusion et perspectives}

\bibliographystyle{abbrv}
\bibliography{mesreferences}

\end{document}
